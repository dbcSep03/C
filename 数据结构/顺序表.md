# 顺序表

## 概念及结构

顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存储。在数组上完成数据的增删查改。

> 连续存储数据，不能跳跃 

顺序表一般可以分为：

1. 静态顺序表：使用定长数组存储元素  
2. 动态顺序表：使用动态开辟的数组存储 

```c
// SeqList.h
#pragma once
#include <stdio.h>
#include <stdlib.h>
//#ifndef __SEQLISR_H__
//#define __SEQLIST_H__
//#endif

// 静态的顺序表 -- 不知道要存储多少数据
#define N 10
typedef int SLDataType;
struct SeqList
{
    SLDataType a[N];
    int size; // 顺序表存储数据的个数
};
// 扩容二倍比较合适，扩容一次扩多了，存在空间浪费，扩少了，导致频繁扩容，效率损失 

//动态顺序表
typedef int SLDataType;
typedef struct SeqList
{
    SLDataType* a;
    int size;          //存储数据的个数
    int capacity;      //存储空间的大小
}SL;


void SLInit(SL* ps1);  //初始化
void SLDestory(SL* ps1); // 销毁

void SLPrint(const SL* ps1);

// 增删查改 头插头删  尾插尾删
void SLPushBack(SL* ps1, SLDataType x);
void SLPushFront(SL* ps1, SLDataType x);
void SLPopBack(SL* ps1);
void SLPopFront(SL* ps1);
```

```C
// seqlist.c

#include "SeqList.h"

void SLInit(SL* ps1)
{
    assert(ps1);
    ps1->a = NULL;
    ps1->size = ps1->capacity = 0;
}

void SLDestory(SL* ps1)
{
    assert(ps1);
    
	if(ps1->a)
    {
        free(ps1->a);   //发生越界
        ps1->a = NULL;
        ps1->size = ps1->capacity = 0;
    }
}
void SLPushBack(SL* ps1, SLDataType x)
{
	assert(ps1);
    
    // 检查容量
    if(ps1->size == ps1->capacity)
    {
        int newCapcity = ps1->capacity == 0 ? 4 :ps1->capacity*2;
        SLDataType* tmp = (SLDataType*)realloc(ps1->a, newCapcity*sizepf(SLDataType));
        if (tmp == NULL)
        {
            perror("realloc fail");
            return;
            //exit(-1);
        }
        
        ps1->a = tmp;
        ps1->capacity = newCapcity;
    }
    ps1->a[ps1->size] = x;
    ps1->size++;
}
void SLPrint(SL* ps1)
{
	assert(ps1);
    for(int i =0;i<ps1->size;++i)
    {
        printf("%d",ps1->a[i]);
    }
    printf("\n");
}

void SLPushFront(SL* ps1, SLDataType x)
{
    assert(ps1);
    SLcheckCapacity(SL* ps1);
    
    //挪动数据
    int end = ps1->size - 1;
    while(end >=0)
    {
        ps1->a[end+1] = ps1->a[end];
        end--;
    }
    ps1->a[0] = x;
    ps1->size++;
}

void SLCheckCapacity(SL* ps1)
{
     if(ps1->size == ps1->capacity)
    {
        int newCapcity = ps1->capacity == 0 ? 4 :ps1->capacity*2;
        SLDataType* tmp = (SLDataType*)realloc(ps1->a, newCapcity*sizepf(SLDataType));
        if (tmp == NULL)
        {
            perror("realloc fail");
            return;
            //exit(-1);
        }
        
        ps1->a = tmp;
        ps1->capacity = newCapcity;
    }
}

void SLPopBack(SL* ps1)
{
    assert(ps1);
    assert(ps1->size > 0);
    ps1->size--;
    
}

void SLPopFront(SL* ps1)
{
    assert(ps1);
    assert(ps1->size>0);
    
    int start = 0;
    while(end < ps1->size-1)
    {
        ps1->a[end] = ps1->a[end+1];
        end++;
    }
    ps1->size--;
}
```

```c
// Test.c
void TestSeqList1()
{
    SL s;
    SLInit(&s);
    SLDestory(&s);
}
int main()
{
    TestSeqList1();
    
    return 0;
}
```











































