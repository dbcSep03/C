# 算法的时间复杂度和空间复杂度

数据结构：在内存中存储管理数据

数据库：在磁盘中存储管理数据

书籍：严蔚敏--数据结构 C实现 殷人昆--数据结构 C++实现

## 算法的复杂度

衡量一个算法的好坏，一般从时间和空间两个维度来衡量的。

时间复杂度主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个所需要的额外空间。

不太关注空间，主要关注时间（由于存储容量已经达到了很高的程度，不需要关注算法的空间复杂度）

### 时间复杂度

算法的时间复杂度是一个函数，算法的基本操作的执行次数，为算法的时间复杂度。

冒泡排序：$O(N^2)$

快速排序：$O(NlogN)$  $log$是以2为底的

### 大O渐进表达式

准确时间复杂度函数式。不方便在算法之间进行比较

大O符号：是用于描述函数渐进行为的数学符号

> 推导大O阶表达式：
>
> 1.常数1取代运行时间中的所有加法常数
>
> 2.在修改后的运行次数函数中，只保留最高阶项
>
> 3.如果最高阶系数存在且不是1，则去除于这个项目相乘的常数，得到的结果就是大O阶

$O(1)$:不是1次而是常数次

### 例子

```c
const char * strchr (const char* str, int character);
//查找一个字符
//O(n)
```

最好情况：任意输入规模的最小运行次数

最坏情况：任意输入规模的最大运行次数

平均情况：任意输入规模的期望运行次数

时间复杂度是以最坏的情况复杂度计算的。

算时间复杂度不能去数循环，这个不一定准确，一定要看算法思想进行计算。

冒泡排序：$F(N) = N-1 +N-2 +N-3 + N-4 +...... +2+1 =\frac{n*(n-1)}{2}$

最好:O(N) =N-1

二分查找：$O(N)=logN$

时间复杂度是计算算法执行的次数，不是语句个数。语句是多条，但肯定是常数。

因为要在文本中写对数不好写，而时间复杂度中，$log_2N$经常出现，所以把他简写为logN，有简写成lgN，不太对，但可以理解为$log_2N$

异或：相同为0，相异为1，不按顺序，两次异或，就消失了。

故查找缺失的值，0与数组先异或，在于1-N异或，剩下就是缺失的数。



递推的层数多了，程序挂掉，栈溢出。(栈:8MB)

## 空间复杂度

空间复杂度：是对一个算法在运行过程中临时占用存储空间大小的量度。

空间复杂度算的是变量的个数，空间复杂度计算规则跟时间复杂度差不多，也有大O渐进表示法。

函数运行时所需要的栈空间(存储参数，局部变量，一些寄存器信息等)在编译期间已经确定好了，因
此空间复杂度主要通过函数在运行时候显式申请的额外空间来确定。

时间是累计的，空间是不累计的，可以重复利用。

```c
long long Fib(size_t N)
{
  if(N < 3)
    return 1;
  return Fib(N-1) +Fib(N-2);
}

//递归到底后，回传后销毁，空间会释放，可以重复利用
//最高用了N个栈帧
```

数组倒置：1.前n-k逆置，后k逆置，整体逆置  2.最后一个取出来，数组向后交换 3.取后k个放进前k个，前n-k个放进后n-k个。